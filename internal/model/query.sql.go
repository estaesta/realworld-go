// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package model

import (
	"context"
	"strings"
)

const addComment = `-- name: AddComment :one
INSERT INTO comment (body, author_id, article_id)
VALUES (?, ?, (SELECT id FROM article WHERE slug = ?))
RETURNING id, body, created_at, updated_at, author_id, article_id
`

type AddCommentParams struct {
	Body     string
	AuthorID int64
	Slug     string
}

func (q *Queries) AddComment(ctx context.Context, arg AddCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, addComment, arg.Body, arg.AuthorID, arg.Slug)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorID,
		&i.ArticleID,
	)
	return i, err
}

const createArticle = `-- name: CreateArticle :one
INSERT INTO article (slug, title, description, body, author_id) 
VALUES (?, ?, ?, ?, ?) 
RETURNING id, created_at, updated_at
`

type CreateArticleParams struct {
	Slug        string
	Title       string
	Description string
	Body        string
	AuthorID    int64
}

type CreateArticleRow struct {
	ID        int64
	CreatedAt string
	UpdatedAt string
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (CreateArticleRow, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.Slug,
		arg.Title,
		arg.Description,
		arg.Body,
		arg.AuthorID,
	)
	var i CreateArticleRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createArticleTag = `-- name: CreateArticleTag :exec
INSERT OR IGNORE INTO article_tag (article_id, tag_id)
SELECT ?, ?
`

type CreateArticleTagParams struct {
	ArticleID int64
	TagID     int64
}

func (q *Queries) CreateArticleTag(ctx context.Context, arg CreateArticleTagParams) error {
	_, err := q.db.ExecContext(ctx, createArticleTag, arg.ArticleID, arg.TagID)
	return err
}

const createTag = `-- name: CreateTag :one
INSERT OR IGNORE INTO tag (name) VALUES (?)
    RETURNING id, name, created_at, updated_at
`

func (q *Queries) CreateTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, createTag, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO user (email, password, username) VALUES (?, ?, ?) RETURNING id, username, email, password, bio, image, created_at, updated_at
`

type CreateUserParams struct {
	Email    string
	Password string
	Username string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.Password, arg.Username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteArticleBySlug = `-- name: DeleteArticleBySlug :exec
DELETE FROM article WHERE slug = ?1
`

func (q *Queries) DeleteArticleBySlug(ctx context.Context, slug string) error {
	_, err := q.db.ExecContext(ctx, deleteArticleBySlug, slug)
	return err
}

const followByUserUsernameAndFollowerID = `-- name: FollowByUserUsernameAndFollowerID :exec
INSERT INTO following (user_id, follower_id)
SELECT u.id, ?
FROM user u
WHERE u.username = ?2
`

type FollowByUserUsernameAndFollowerIDParams struct {
	FollowerID int64
	Username   string
}

func (q *Queries) FollowByUserUsernameAndFollowerID(ctx context.Context, arg FollowByUserUsernameAndFollowerIDParams) error {
	_, err := q.db.ExecContext(ctx, followByUserUsernameAndFollowerID, arg.FollowerID, arg.Username)
	return err
}

const getArticleAuthorBySlug = `-- name: GetArticleAuthorBySlug :one
SELECT author_id FROM article
WHERE slug = ?
`

func (q *Queries) GetArticleAuthorBySlug(ctx context.Context, slug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getArticleAuthorBySlug, slug)
	var author_id int64
	err := row.Scan(&author_id)
	return author_id, err
}

const getArticleBySlug = `-- name: GetArticleBySlug :one
SELECT article.id, article.slug, article.title, article.description, article.body, article.created_at, article.updated_at, article.author_id, 
    user.id, user.username, user.email, user.password, user.bio, user.image, user.created_at, user.updated_at, 
    IFNULL(GROUP_CONCAT(tag.name), '') AS tags,
    CASE
        WHEN EXISTS(
        SELECT 1 FROM favorite WHERE article_id = article.id 
            AND favorite.user_id = ?1
        ) THEN 1
        ELSE 0
    END AS favorited,
    (SELECT COUNT(*) FROM favorite
    WHERE article_id = article.id) AS favorites_count,
    CASE
        WHEN following.user_id IS NOT NULL THEN 1
        ELSE 0
    END AS is_following
FROM article 
JOIN user ON article.author_id = user.id
LEFT JOIN article_tag ON article.id = article_tag.article_id
LEFT JOIN tag ON article_tag.tag_id = tag.id
LEFT JOIN favorite ON article.id = favorite.article_id
LEFT JOIN following ON article.author_id = following.user_id AND following.follower_id = ?1
WHERE slug = ?2
GROUP BY article.id
`

type GetArticleBySlugParams struct {
	UserID int64
	Slug   string
}

type GetArticleBySlugRow struct {
	Article        Article
	User           User
	Tags           interface{}
	Favorited      int64
	FavoritesCount int64
	IsFollowing    int64
}

func (q *Queries) GetArticleBySlug(ctx context.Context, arg GetArticleBySlugParams) (GetArticleBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleBySlug, arg.UserID, arg.Slug)
	var i GetArticleBySlugRow
	err := row.Scan(
		&i.Article.ID,
		&i.Article.Slug,
		&i.Article.Title,
		&i.Article.Description,
		&i.Article.Body,
		&i.Article.CreatedAt,
		&i.Article.UpdatedAt,
		&i.Article.AuthorID,
		&i.User.ID,
		&i.User.Username,
		&i.User.Email,
		&i.User.Password,
		&i.User.Bio,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.Tags,
		&i.Favorited,
		&i.FavoritesCount,
		&i.IsFollowing,
	)
	return i, err
}

const getArticlesFeed = `-- name: GetArticlesFeed :many
SELECT 
    article.id,
    article.slug,
    article.title,
    article.description,
    IFNULL(GROUP_CONCAT(tag.name), '') AS tags,
    CASE
        WHEN EXISTS(
        SELECT 1 FROM favorite WHERE article_id = article.id 
            AND favorite.user_id = ?1
        ) THEN 1
        ELSE 0
    END AS favorited,
    (SELECT COUNT(*) FROM favorite
    WHERE article_id = article.id) AS favorites_count,
    article.created_at,
    article.updated_at,
    user.id, user.username, user.email, user.password, user.bio, user.image, user.created_at, user.updated_at
FROM article
LEFT JOIN user ON article.author_id = user.id
LEFT JOIN article_tag ON article.id = article_tag.article_id
LEFT JOIN tag ON article_tag.tag_id = tag.id
LEFT JOIN favorite ON article.id = favorite.article_id
JOIN following ON article.author_id = following.user_id AND following.follower_id = ?1
GROUP BY article.id
LIMIT ?3 OFFSET ?2
`

type GetArticlesFeedParams struct {
	UserID int64
	Offset int64
	Limit  int64
}

type GetArticlesFeedRow struct {
	ID             int64
	Slug           string
	Title          string
	Description    string
	Tags           interface{}
	Favorited      int64
	FavoritesCount int64
	CreatedAt      string
	UpdatedAt      string
	User           User
}

func (q *Queries) GetArticlesFeed(ctx context.Context, arg GetArticlesFeedParams) ([]GetArticlesFeedRow, error) {
	rows, err := q.db.QueryContext(ctx, getArticlesFeed, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArticlesFeedRow
	for rows.Next() {
		var i GetArticlesFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.Description,
			&i.Tags,
			&i.Favorited,
			&i.FavoritesCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.Email,
			&i.User.Password,
			&i.User.Bio,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticlesList = `-- name: GetArticlesList :many
SELECT 
    article.id,
    article.slug,
    article.title,
    article.description,
    IFNULL(GROUP_CONCAT(tag.name), '') AS tags,
    CASE
        WHEN EXISTS(
        SELECT 1 FROM favorite WHERE article_id = article.id 
            AND favorite.user_id = ?1
        ) THEN 1
        ELSE 0
    END AS favorited,
    (SELECT COUNT(*) FROM favorite
    WHERE article_id = article.id) AS favorites_count,
    article.created_at,
    article.updated_at,
    user.id, user.username, user.email, user.password, user.bio, user.image, user.created_at, user.updated_at,
    CASE
        WHEN following.user_id IS NOT NULL THEN 1
        ELSE 0
    END AS is_following
FROM article
LEFT JOIN user ON article.author_id = user.id
LEFT JOIN article_tag ON article.id = article_tag.article_id
LEFT JOIN tag ON article_tag.tag_id = tag.id
LEFT JOIN favorite ON article.id = favorite.article_id
LEFT JOIN following ON article.author_id = following.user_id AND following.follower_id = ?1
WHERE (user.username = ?2 or ?2 = '')
    AND (tag.name = ?3 or ?3 = '')
    AND (favorite.user_id = ?4 or ?4 = 0)
GROUP BY article.id
LIMIT ?6 OFFSET ?5
`

type GetArticlesListParams struct {
	UserID    int64
	Author    string
	Tag       string
	Favorited int64
	Offset    int64
	Limit     int64
}

type GetArticlesListRow struct {
	ID             int64
	Slug           string
	Title          string
	Description    string
	Tags           interface{}
	Favorited      int64
	FavoritesCount int64
	CreatedAt      string
	UpdatedAt      string
	User           User
	IsFollowing    int64
}

func (q *Queries) GetArticlesList(ctx context.Context, arg GetArticlesListParams) ([]GetArticlesListRow, error) {
	rows, err := q.db.QueryContext(ctx, getArticlesList,
		arg.UserID,
		arg.Author,
		arg.Tag,
		arg.Favorited,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArticlesListRow
	for rows.Next() {
		var i GetArticlesListRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.Description,
			&i.Tags,
			&i.Favorited,
			&i.FavoritesCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.Email,
			&i.User.Password,
			&i.User.Bio,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.IsFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTags = `-- name: GetTags :many
SELECT id, name, created_at, updated_at FROM tag WHERE name IN(/*SLICE:tags*/?)
`

func (q *Queries) GetTags(ctx context.Context, tags []string) ([]Tag, error) {
	query := getTags
	var queryParams []interface{}
	if len(tags) > 0 {
		for _, v := range tags {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:tags*/?", strings.Repeat(",?", len(tags))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:tags*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password, bio, image, created_at, updated_at FROM user WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password, bio, image, created_at, updated_at FROM user WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password, bio, image, created_at, updated_at FROM user WHERE username = ? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isFavoriteByUserIDAndArticleID = `-- name: IsFavoriteByUserIDAndArticleID :one
SELECT COUNT(*) FROM favorite
WHERE user_id = ?
AND article_id = ?
`

type IsFavoriteByUserIDAndArticleIDParams struct {
	UserID    int64
	ArticleID int64
}

func (q *Queries) IsFavoriteByUserIDAndArticleID(ctx context.Context, arg IsFavoriteByUserIDAndArticleIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isFavoriteByUserIDAndArticleID, arg.UserID, arg.ArticleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isUserFollowByUserID = `-- name: IsUserFollowByUserID :one
SELECT COUNT(*) FROM following
WHERE user_id = ?
AND follower_id = ?
`

type IsUserFollowByUserIDParams struct {
	UserID     int64
	FollowerID int64
}

func (q *Queries) IsUserFollowByUserID(ctx context.Context, arg IsUserFollowByUserIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isUserFollowByUserID, arg.UserID, arg.FollowerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const unfollowByUserIDAndFollowerID = `-- name: UnfollowByUserIDAndFollowerID :exec
DELETE FROM following
WHERE user_id = ?1
AND follower_id = ?2
`

type UnfollowByUserIDAndFollowerIDParams struct {
	UserID     int64
	FollowerID int64
}

func (q *Queries) UnfollowByUserIDAndFollowerID(ctx context.Context, arg UnfollowByUserIDAndFollowerIDParams) error {
	_, err := q.db.ExecContext(ctx, unfollowByUserIDAndFollowerID, arg.UserID, arg.FollowerID)
	return err
}

const updateArticle = `-- name: UpdateArticle :one
UPDATE article SET
    title = COALESCE(?1, title),
    description = COALESCE(?2, description),
    body = COALESCE(?3, body),
    updated_at = (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
WHERE slug = ?4
RETURNING slug
`

type UpdateArticleParams struct {
	Title       *string
	Description *string
	Body        *string
	Slug        string
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) (string, error) {
	row := q.db.QueryRowContext(ctx, updateArticle,
		arg.Title,
		arg.Description,
		arg.Body,
		arg.Slug,
	)
	var slug string
	err := row.Scan(&slug)
	return slug, err
}

const updateUserByID = `-- name: UpdateUserByID :one
UPDATE user SET
    email = COALESCE(?1, email),
    username = COALESCE(?2, username),
    password = COALESCE(?3, password),
    image = COALESCE(?4, image),
    bio = COALESCE(?5, bio),
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?6
RETURNING username, email, bio, image
`

type UpdateUserByIDParams struct {
	Email    *string
	Username *string
	Password *string
	Image    *string
	Bio      *string
	ID       int64
}

type UpdateUserByIDRow struct {
	Username string
	Email    string
	Bio      *string
	Image    *string
}

func (q *Queries) UpdateUserByID(ctx context.Context, arg UpdateUserByIDParams) (UpdateUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, updateUserByID,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.Image,
		arg.Bio,
		arg.ID,
	)
	var i UpdateUserByIDRow
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.Bio,
		&i.Image,
	)
	return i, err
}
