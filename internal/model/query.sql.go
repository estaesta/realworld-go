// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package model

import (
	"context"
	"strings"
	"time"
)

const createArticle = `-- name: CreateArticle :one
INSERT INTO article (slug, title, description, body, author_id) 
VALUES (?, ?, ?, ?, ?) 
RETURNING id, created_at
`

type CreateArticleParams struct {
	Slug        string
	Title       string
	Description string
	Body        string
	AuthorID    int64
}

type CreateArticleRow struct {
	ID        int64
	CreatedAt time.Time
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (CreateArticleRow, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.Slug,
		arg.Title,
		arg.Description,
		arg.Body,
		arg.AuthorID,
	)
	var i CreateArticleRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createArticleTag = `-- name: CreateArticleTag :exec
INSERT OR IGNORE INTO article_tag (article_id, tag_id)
SELECT ?, ?
`

type CreateArticleTagParams struct {
	ArticleID int64
	TagID     int64
}

func (q *Queries) CreateArticleTag(ctx context.Context, arg CreateArticleTagParams) error {
	_, err := q.db.ExecContext(ctx, createArticleTag, arg.ArticleID, arg.TagID)
	return err
}

const createTag = `-- name: CreateTag :one
INSERT OR IGNORE INTO tag (name) VALUES (?)
    RETURNING id, name, created_at, updated_at
`

func (q *Queries) CreateTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, createTag, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO user (email, password, username) VALUES (?, ?, ?) RETURNING id, username, email, password, bio, image, created_at, updated_at
`

type CreateUserParams struct {
	Email    string
	Password string
	Username string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.Password, arg.Username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const followByUserUsernameAndFollowerID = `-- name: FollowByUserUsernameAndFollowerID :exec
INSERT INTO following (user_id, follower_id)
SELECT u.id, ?
FROM user u
WHERE u.username = ?2
`

type FollowByUserUsernameAndFollowerIDParams struct {
	FollowerID int64
	Username   string
}

func (q *Queries) FollowByUserUsernameAndFollowerID(ctx context.Context, arg FollowByUserUsernameAndFollowerIDParams) error {
	_, err := q.db.ExecContext(ctx, followByUserUsernameAndFollowerID, arg.FollowerID, arg.Username)
	return err
}

const getArticleBySlug = `-- name: GetArticleBySlug :one
SELECT article.id, article.slug, article.title, article.description, article.body, article.created_at, article.updated_at, article.author_id, user.id, user.username, user.email, user.password, user.bio, user.image, user.created_at, user.updated_at, GROUP_CONCAT(tag.name) AS tag
FROM article 
JOIN user ON article.author_id = user.id
JOIN article_tag ON article.id = article_tag.article_id
JOIN tag ON article_tag.tag_id = tag.id
WHERE slug = ?
`

type GetArticleBySlugRow struct {
	Article Article
	User    User
	Tag     string
}

func (q *Queries) GetArticleBySlug(ctx context.Context, slug string) (GetArticleBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleBySlug, slug)
	var i GetArticleBySlugRow
	err := row.Scan(
		&i.Article.ID,
		&i.Article.Slug,
		&i.Article.Title,
		&i.Article.Description,
		&i.Article.Body,
		&i.Article.CreatedAt,
		&i.Article.UpdatedAt,
		&i.Article.AuthorID,
		&i.User.ID,
		&i.User.Username,
		&i.User.Email,
		&i.User.Password,
		&i.User.Bio,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.Tag,
	)
	return i, err
}

const getTags = `-- name: GetTags :many
SELECT id, name, created_at, updated_at FROM tag WHERE name IN(/*SLICE:tags*/?)
`

func (q *Queries) GetTags(ctx context.Context, tags []string) ([]Tag, error) {
	query := getTags
	var queryParams []interface{}
	if len(tags) > 0 {
		for _, v := range tags {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:tags*/?", strings.Repeat(",?", len(tags))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:tags*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password, bio, image, created_at, updated_at FROM user WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password, bio, image, created_at, updated_at FROM user WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password, bio, image, created_at, updated_at FROM user WHERE username = ? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isFavoriteByUserIDAndArticleID = `-- name: IsFavoriteByUserIDAndArticleID :one
SELECT COUNT(*) FROM favorite
WHERE user_id = ?
AND article_id = ?
`

type IsFavoriteByUserIDAndArticleIDParams struct {
	UserID    int64
	ArticleID int64
}

func (q *Queries) IsFavoriteByUserIDAndArticleID(ctx context.Context, arg IsFavoriteByUserIDAndArticleIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isFavoriteByUserIDAndArticleID, arg.UserID, arg.ArticleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isUserFollowByUserID = `-- name: IsUserFollowByUserID :one
SELECT COUNT(*) FROM following
WHERE user_id = ?
AND follower_id = ?
`

type IsUserFollowByUserIDParams struct {
	UserID     int64
	FollowerID int64
}

func (q *Queries) IsUserFollowByUserID(ctx context.Context, arg IsUserFollowByUserIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isUserFollowByUserID, arg.UserID, arg.FollowerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const unfollowByUserIDAndFollowerID = `-- name: UnfollowByUserIDAndFollowerID :exec
DELETE FROM following
WHERE user_id = ?1
AND follower_id = ?2
`

type UnfollowByUserIDAndFollowerIDParams struct {
	UserID     int64
	FollowerID int64
}

func (q *Queries) UnfollowByUserIDAndFollowerID(ctx context.Context, arg UnfollowByUserIDAndFollowerIDParams) error {
	_, err := q.db.ExecContext(ctx, unfollowByUserIDAndFollowerID, arg.UserID, arg.FollowerID)
	return err
}

const updateUserByID = `-- name: UpdateUserByID :one
UPDATE user SET
    email = COALESCE(?1, email),
    username = COALESCE(?2, username),
    password = COALESCE(?3, password),
    image = COALESCE(?4, image),
    bio = COALESCE(?5, bio),
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?6
RETURNING username, email, bio, image
`

type UpdateUserByIDParams struct {
	Email    *string
	Username *string
	Password *string
	Image    *string
	Bio      *string
	ID       int64
}

type UpdateUserByIDRow struct {
	Username string
	Email    string
	Bio      *string
	Image    *string
}

func (q *Queries) UpdateUserByID(ctx context.Context, arg UpdateUserByIDParams) (UpdateUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, updateUserByID,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.Image,
		arg.Bio,
		arg.ID,
	)
	var i UpdateUserByIDRow
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.Bio,
		&i.Image,
	)
	return i, err
}
